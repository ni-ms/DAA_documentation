"use strict";(self.webpackChunkdaadocs=self.webpackChunkdaadocs||[]).push([[671],{3905:(e,t,n)=>{n.d(t,{Zo:()=>g,kt:()=>u});var i=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=i.createContext({}),d=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},g=function(e){var t=d(e.components);return i.createElement(l.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},c=i.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,g=s(e,["components","mdxType","originalType","parentName"]),p=d(n),c=o,u=p["".concat(l,".").concat(c)]||p[c]||m[c]||r;return n?i.createElement(u,a(a({ref:t},g),{},{components:n})):i.createElement(u,a({ref:t},g))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,a=new Array(r);a[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:o,a[1]=s;for(var d=2;d<r;d++)a[d]=n[d];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}c.displayName="MDXCreateElement"},9881:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var i=n(7462),o=(n(7294),n(3905));const r={},a="Assignment - 1, Design And Analysis Of Algorithm",s={unversionedId:"intro",id:"intro",title:"Assignment - 1, Design And Analysis Of Algorithm",description:"Team Members",source:"@site/docs/intro.md",sourceDirName:".",slug:"/intro",permalink:"/docs/intro",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/intro.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar"},l={},d=[{value:"Team Members",id:"team-members",level:2},{value:"Methodology",id:"methodology",level:2},{value:"1. DCEL Data Structure",id:"1-dcel-data-structure",level:3},{value:"2. Polygon Decomposition Algorithm",id:"2-polygon-decomposition-algorithm",level:3},{value:"3. Merge Algorithm",id:"3-merge-algorithm",level:3},{value:"3.1 Need for Merging",id:"31-need-for-merging",level:4},{value:"3.2 Implementation Summary",id:"32-implementation-summary",level:4},{value:"Results",id:"results",level:2},{value:"Visualization",id:"visualization",level:3},{value:"Test Cases and Time Complexity",id:"test-cases-and-time-complexity",level:3}],g={toc:d},p="wrapper";function m(e){let{components:t,...r}=e;return(0,o.kt)(p,(0,i.Z)({},g,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"assignment---1-design-and-analysis-of-algorithm"},"Assignment - 1, Design And Analysis Of Algorithm"),(0,o.kt)("h2",{id:"team-members"},"Team Members"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"NAME"),(0,o.kt)("th",{parentName:"tr",align:null},"ID"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Kartikeya Dubey"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"2020A7PS0031H"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Nikhil Madhav Sharma"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"2020A7PS1303H"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Prajwal Singh"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"2020A7PS0192H"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Anurag Saxena"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"2020A7PS1290H"))))),(0,o.kt)("h1",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"This assignment focuses on a well-known problem of decomposing a polygon into subsets of convex polygons without introducing new vertices. This process of polygon decomposition has several crucial applications in various fields, such as Pattern Recognition, Computational Geometry, Data Compression, Image Processing, and Computer Graphics.\nIn this submission, we will discuss the procedure of decomposing a polygon into convex polygons without adding new vertices. Additionally, we will cover a technique that can be used to remove unnecessary edges from the partition by ",(0,o.kt)("strong",{parentName:"p"},"merging")," the polygons whose union remains a convex polygon. The importance of this procedure lies in its ability to extract information from an object to describe, identify, or classify it. By understanding this technique, we can utilize it to solve many problems that require the partitioning of polygons."),(0,o.kt)("h2",{id:"methodology"},"Methodology"),(0,o.kt)("h3",{id:"1-dcel-data-structure"},"1. DCEL Data Structure"),(0,o.kt)("p",null,"The DCEL data structure, which stands for Doubly-Connected Edge List, is a powerful tool used in computational geometry to represent planar subdivisions. Essentially, the DCEL stores information about the topology of a polygon, including the location of its vertices, edges, and faces.\nIn the context of our assignment, we used the DCEL data structure to store a given polygon. This means that each vertex of the polygon was represented by a vertex node in the DCEL, each edge by an edge node, and each face by a face node. The edge nodes were particularly important because they stored pointers to their incident vertices, adjacent faces, and their twin edge, which is essentially the edge that is the reverse of the current edge. This allowed us to efficiently navigate the polygon, such as iterating over the edges that touch a particular vertex, or finding the faces that share a particular edge."),(0,o.kt)("p",null,"Below is a pseducode showing a simplified version of implementation of DCEL or Doubly-Connected Edge list Data Structure for storing a polygon:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'  class face {\n  int edge;\n\n  public face(int e) {\n    edge = e < 0 ? e - 1 : e + 1;\n  }\n\n  public void printFace() {\n    if (edge >= 0)\n      System.out.println("Face with bounding edge: Forward " + edge);\n    if (edge < 0)\n      System.out.println("Face with bounding edge: Backward " + edge * -1);\n  }\n}\n\nclass vertex {\n  double x, y;\n  int id;\n  int inc_Edge;\n\n  public vertex() {}\n\n  public vertex(double x, double y, int id) {\n\n    this.id = id;\n    this.x = x;\n    this.y = y;\n  }\n\n  public vertex(vertex v, int id) {\n    this.id = id;\n    this.x = v.x;\n    this.y = v.y;\n  }\n\n  public void setIncEdge(int e) {\n    inc_Edge = e;\n  }\n\n  public String stringForm() {\n    return "(" + x + ", " + y + ") and edge: " + inc_Edge;\n  }\n}\n\nclass edge {\n  int twin;\n  int next;\n  int prev;\n\n  int origin;\n  int dest;\n\n  public edge(int o, int d) {\n    origin = o;\n    dest = d;\n  }\n\n  public void printEdge(ArrayList < vertex > vi, int i) {\n    System.out.println(\n      ++i + ". Edge with origin: " + vi.get(origin).stringForm() +\n      " and dest: " + vi.get(dest).stringForm() +\n      " with next: " + next +\n      " and prev: " + prev\n    );\n  }\n\n  public void setNext(ArrayList < edge > edgesTwin, int e) {\n    next = e;\n    edgesTwin.get(twin).prev = e;\n  }\n\n  public void setPrev(ArrayList < edge > edgesTwin, int e) {\n    prev = e;\n    edgesTwin.get(twin).next = e;\n  }\n} \n')),(0,o.kt)("h3",{id:"2-polygon-decomposition-algorithm"},"2. Polygon Decomposition Algorithm"),(0,o.kt)("p",null,"After storing our polygon in the aforementioned DCEL Data structure, our next step is to decompose it into smaller polygons that are convex in nature where taking into account that the smaller polygons generated are the largest possible convex polygons and not just triangulations in the initial polygon. This is achieved using the divide and conquer methodology to generate convex polygons of the partitions. "),(0,o.kt)("p",null,"We begin with a simple polygon, P, with its vertices considered and assumed in clockwise order. The algorithm is implemented on this particular polygon P, and as it progresses, P will be modified by cutting off the convex polygons generated thus far. These generated polygons are stored in a list, L, which is initialized with a single vertex. The convex polygon with the highest possible number of vertices is generated by continuously adding supposed vertices into L.\nFurther, If the list L contains all the edges of the polygon, the algorithm stops indicating that the initial polygon is convex in nature while if L, has only v1 and v2 then it is considered an edge and the algorithm stops yet again."),(0,o.kt)("p",null,'Finally, the convex polygon is obtained by drawing the diagonal joining the last and first vertices of L. However, it is possible that the convex polygon created by the diagonal joining the last vertex to the initial vertex contains one of the interior vertices of P, and hence we need to handle this externally.\nTo address this issue, we initialize a "check" that generates the smallest rectangle R with sides parallel to the axes. If a given "v" is not inside the rectangle R, then it cannot be inside the polygon generated by the vertices of our earlier list L, and hence the problem is solved.'),(0,o.kt)("p",null,"Below is a pseducode showing a simplified version of implementation of the mentioned Decomposition algorithm used in our assignment:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'      void runAlgorithm() {\n      System.out.println("====================================================================");\n\n      while (n > 3) {\n\n        System.out.println(n);\n        this.algo();\n        System.out.println(n);\n        System.out.println("====================================================================");\n\n      }\n    }\n\n    void algo() {\n\n      int i = 2;\n      vertex vi = v2;\n\n      vertex vi1 = origiPolygon.vertices.get(origiPolygon.edgesF.get(v2.inc_Edge).dest);\n\n      vertex vim1 = v1;\n      System.out.println(vi1.stringForm());\n\n      int t = origiPolygon.findIndOfVert(v1);\n      vertex tempV = v2;\n\n      ArrayList < vertex > verts = new ArrayList < > ();\n\n      polygon poly = new polygon();\n      poly.addVertex(v1);\n      poly.addVertex(v2);\n      poly.addEdge(i - 2, i - 1);\n\n      while (threeConditionsDam(v1, v2, vi, vi1, vim1) && verts.size() < origiPolygon.numV - 2) {\n        i++;\n        System.out.println("Adding: " + vi1.stringForm());\n        verts.add(vi1);\n        for (vertex te: verts) {\n          System.out.println(te.stringForm());\n        }\n\n        poly.addVertex(vi1);\n        poly.addEdge(i - 2, i - 1);\n\n        vim1 = vi;\n        vi = vi1;\n\n        vi1 = origiPolygon.vertices.get(origiPolygon.edgesF.get(vi.inc_Edge).dest);\n      }\n\n      poly.addEdge(poly.numV - 1, 0);\n\n      v1 = vi;\n      v2 = vi1;\n      System.out.println("V1: " + v1.stringForm() + " V2: " + v2.stringForm());\n\n      for (vertex temp: origiPolygon.vertices) {\n        while (poly.isPointIn(temp) && poly.numV > 2) {\n\n          poly.removeLastEdge();\n          poly.removeLastVertexAndEdge();\n\n          v2 = verts.get(verts.size() - 1);\n          verts.remove(verts.size() - 1);\n\n          v1 = verts.size() >= 1 ? verts.get(verts.size() - 1) : tempV;\n\n          poly.addEdge(poly.numV - 1, 0);\n\n          System.out.println("Removing");\n          for (vertex te: verts) {\n            System.out.println(te.stringForm());\n          }\n\n        }\n      }\n\n      System.out.println("Pruning done: ");\n\n      for (vertex te: verts) {\n        System.out.println(te.stringForm());\n      }\n\n      System.out.println("V1: " + v1.stringForm() + " V2: " + v2.stringForm());\n\n      if (poly.numV > 2) {\n\n        int ind = origiPolygon.findIndOfVert(verts.get(verts.size() - 1));\n\n        origiPolygon.addEdge(t, ind);\n        origiPolygon.removeLastFace();\n        origiPolygon.addFaceWithLastEdge();\n\n        n = n + 2 - poly.numV;\n      }\n\n    }\n\n    public boolean threeConditionsDam(vertex a, vertex b, vertex vi, vertex vi1, vertex vim1) {\n      if (origiPolygon.cross(vi1, vi, vim1) < 0) {\n\n        return false;\n      }\n      if (origiPolygon.cross(a, vi1, vi) < 0) {\n\n        return false;\n      }\n\n      return !(origiPolygon.cross(b, a, vi1) < 0);\n    }\n')),(0,o.kt)("h3",{id:"3-merge-algorithm"},"3. Merge Algorithm"),(0,o.kt)("h4",{id:"31-need-for-merging"},"3.1 Need for Merging"),(0,o.kt)("p",null,"At times, the partitions generated using the above-mentioned technique, i.e., the decomposition algorithm, may have unnecessary diagonals. This could be when the two convex polygons sharing a diagonal can be combined to form a single polygon. To avoid this, we have made use of a merging algorithm."),(0,o.kt)("h4",{id:"32-implementation-summary"},"3.2 Implementation Summary"),(0,o.kt)("p",null,"In the merging process, we begin by distinguishing diagonals as essential and inessential. A diagonal, d, is considered and classified as essential for vertex v if its elimination causes a piece that is not convex at v. Subsequently, each diagonal is evaluated to determine if it can be removed and whenever necessary, the diagonal is eliminated."),(0,o.kt)("p",null,"Below is a pseducode showing a simplified version of implementation of the mentioned Merging algorithm used in our assignment:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'    class mergingAlgo {\n\n      ArrayList < edge > LLE;\n\n      ArrayList < ArrayList < edge >> LPuj;\n\n      ArrayList < Boolean > LDP;\n\n      ArrayList < Integer > LUP;\n\n      int m, NP;\n\n      public void getDiagonals(polygon p, int initVert) {\n\n        LLE = new ArrayList < > ();\n\n        for (int i = 0; i < p.vertices.size(); i++) {\n\n          if (p.edgesF.get(i).next == 0 && p.edgesF.get(i).prev == 0) {\n            LLE.add(new edge(p.edgesF.get(i).origin, p.edgesF.get(i).dest));\n          }\n\n        }\n\n      }\n\n      public void printDiagonalCoords() {\n\n        for (int i = 0; i < LLE.size(); i++) {\n          System.out.println("Diagonal " + i + ": (" + LLE.get(i).origin + ", " + LLE.get(i).dest + ")");\n        }\n      }\n\n      void initialize(polygon p) {\n\n        for (int i = 1; i < LLE.size(); i++) {\n\n          vertex origin = p.vertices.get(LLE.get(i).origin);\n          vertex dest = p.vertices.get(LLE.get(i).dest);\n\n          vertex prevOrigin = p.vertices.get(LLE.get(LLE.get(i).prev).origin);\n\n          vertex nextOrigin = p.vertices.get(LLE.get(LLE.get(i).next).origin);\n          vertex prevDest = p.vertices.get(LLE.get(LLE.get(i).prev).dest);\n          vertex nextDest = p.vertices.get(LLE.get(LLE.get(i).next).dest);\n\n          if (isConvex(prevOrigin, origin, nextOrigin) && isConvex(prevDest, dest, nextDest)) {\n\n            LLE.remove(i);\n          }\n        }\n\n      }\n\n      private static boolean orientation(vertex p, vertex q, vertex r) {\n        return (q.y - p.y) * (r.x - q.x) >= (q.x - p.x) * (r.y - q.y);\n      }\n\n      private static boolean isConvex(vertex p, vertex q, vertex r) {\n        return orientation(p, q, r) && orientation(q, r, p) && orientation(r, p, q);\n      }\n\n      private static boolean vertexEqualityAfterAbsorption(vertex v1, vertex v2) {\n        return (v1.x == v2.x && v1.y == v2.y);\n      }\n\n    }\n')),(0,o.kt)("h2",{id:"results"},"Results"),(0,o.kt)("h3",{id:"visualization"},"Visualization"),(0,o.kt)("p",null,"To show our resultant polygon in a appealing manner, we generated a UI interface using Swing in java which shows the polygon taken as the input and the resultant polygon after the decomposition algorithm as well as the final polygon after the merging process."),(0,o.kt)("p",null,"Below is a snippet showing the implementation of the UI Interface.\n",(0,o.kt)("img",{alt:"image1",src:n(7171).Z,width:"700",height:"481"})),(0,o.kt)("p",null,"Before Decomposition"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"image2",src:n(2194).Z,width:"708",height:"490"})),(0,o.kt)("p",null,"After Decomposition"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"image3",src:n(1029).Z,width:"702",height:"483"})),(0,o.kt)("p",null,"After Merging"),(0,o.kt)("p",null,"Further, We also constructed a django based interface which uses HTML Canvas element which enables us to draw our input polygons concering the different vertices and using the rest API it finally outputs the resultant polygon as well. The input shape is sent to the back end via an API written in python. The back end then runs the java code and the output of the java code is stored in a text file. Then, the resulting vertices are displayed on the front end through another API in django."),(0,o.kt)("p",null,"Below is a snippet showing the same."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"image4",src:n(1568).Z,width:"1600",height:"777"})),(0,o.kt)("p",null,"HTML Canvas"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"image5",src:n(3766).Z,width:"1600",height:"779"})),(0,o.kt)("p",null,"Input Shape"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"image6",src:n(9065).Z,width:"1600",height:"780"})),(0,o.kt)("p",null,"Final Result"),(0,o.kt)("h3",{id:"test-cases-and-time-complexity"},"Test Cases and Time Complexity"),(0,o.kt)("p",null,"After completing the implementation of the the algorithm described above in the Methodology section, we tested our implementation of various data sets, we systematically figured out that the time complexity is propotional to O(n^3) owning to major time contribution in the Decomposition Algorithm."),(0,o.kt)("p",null,"The run times for a polygon is as follows:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Number of vertices"),(0,o.kt)("th",{parentName:"tr",align:null},"Time"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"n = 8"),(0,o.kt)("td",{parentName:"tr",align:null},"Time taken: 12204999 nanoseconds")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"n = 16"),(0,o.kt)("td",{parentName:"tr",align:null},"Time taken: 11824500 nanoseconds")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"n = 32"),(0,o.kt)("td",{parentName:"tr",align:null},"Time taken: 11814300 nanoseconds")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"n = 64"),(0,o.kt)("td",{parentName:"tr",align:null},"Time taken: 12257701 nanoseconds")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"n = 150"),(0,o.kt)("td",{parentName:"tr",align:null},"Time taken: 12311901 nanoseconds")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"n = 200"),(0,o.kt)("td",{parentName:"tr",align:null},"Time taken: 13457701 nanoseconds")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"n = 500"),(0,o.kt)("td",{parentName:"tr",align:null},"Time taken: 10986651 nanoseconds")))))}m.isMDXComponent=!0},7171:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/img1-b270e6eaee112609ab45a2a372c567a1.jpeg"},2194:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/img2-9c84b3ea528e6d4a9e5d39c46c342c20.jpeg"},1029:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/img3-bfce55a679893fa2aae342e63e5cac58.jpeg"},1568:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/img4-0dec821d17089b918568558986f627a0.jpeg"},3766:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/img5-3f093616070fca74dbb9e6b6555d7121.jpeg"},9065:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/img6-bc9a827d511a786c91b6df50e9efebd1.jpeg"}}]);