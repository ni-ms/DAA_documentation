<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-intro">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.0">
<title data-rh="true">Assignment - 1, Design And Analysis Of Algorithm | DAA Assignment Docs</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://your-docusaurus-test-site.com/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://your-docusaurus-test-site.com/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://your-docusaurus-test-site.com/docs/intro"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Assignment - 1, Design And Analysis Of Algorithm | DAA Assignment Docs"><meta data-rh="true" name="description" content="Team Members"><meta data-rh="true" property="og:description" content="Team Members"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://your-docusaurus-test-site.com/docs/intro"><link data-rh="true" rel="alternate" href="https://your-docusaurus-test-site.com/docs/intro" hreflang="en"><link data-rh="true" rel="alternate" href="https://your-docusaurus-test-site.com/docs/intro" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="DAA Assignment Docs RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="DAA Assignment Docs Atom Feed"><link rel="stylesheet" href="/assets/css/styles.6d611281.css">
<link rel="preload" href="/assets/js/runtime~main.253a65e8.js" as="script">
<link rel="preload" href="/assets/js/main.5ae705ac.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">DAA Docs</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">Tutorial</a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/docs/intro">Assignment - 1, Design And Analysis Of Algorithm</a></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Assignment - 1, Design And Analysis Of Algorithm</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>Assignment - 1, Design And Analysis Of Algorithm</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="team-members">Team Members<a href="#team-members" class="hash-link" aria-label="Direct link to Team Members" title="Direct link to Team Members">​</a></h2><table><thead><tr><th>NAME</th><th>ID</th></tr></thead><tbody><tr><td>Kartikeya Dubey</td><td><code>2020A7PS0031H</code></td></tr><tr><td>Nikhil Madhav Sharma</td><td><code>2020A7PS1303H</code></td></tr><tr><td>Prajwal Singh</td><td><code>2020A7PS0192H</code></td></tr><tr><td>Anurag Saxena</td><td><code>2020A7PS1290H</code></td></tr></tbody></table><h1>Introduction</h1><p>This assignment focuses on a well-known problem of decomposing a polygon into subsets of convex polygons without introducing new vertices. This process of polygon decomposition has several crucial applications in various fields, such as Pattern Recognition, Computational Geometry, Data Compression, Image Processing, and Computer Graphics.
In this submission, we will discuss the procedure of decomposing a polygon into convex polygons without adding new vertices. Additionally, we will cover a technique that can be used to remove unnecessary edges from the partition by <strong>merging</strong> the polygons whose union remains a convex polygon. The importance of this procedure lies in its ability to extract information from an object to describe, identify, or classify it. By understanding this technique, we can utilize it to solve many problems that require the partitioning of polygons.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="methodology">Methodology<a href="#methodology" class="hash-link" aria-label="Direct link to Methodology" title="Direct link to Methodology">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-dcel-data-structure">1. DCEL Data Structure<a href="#1-dcel-data-structure" class="hash-link" aria-label="Direct link to 1. DCEL Data Structure" title="Direct link to 1. DCEL Data Structure">​</a></h3><p>The DCEL data structure, which stands for Doubly-Connected Edge List, is a powerful tool used in computational geometry to represent planar subdivisions. Essentially, the DCEL stores information about the topology of a polygon, including the location of its vertices, edges, and faces.
In the context of our assignment, we used the DCEL data structure to store a given polygon. This means that each vertex of the polygon was represented by a vertex node in the DCEL, each edge by an edge node, and each face by a face node. The edge nodes were particularly important because they stored pointers to their incident vertices, adjacent faces, and their twin edge, which is essentially the edge that is the reverse of the current edge. This allowed us to efficiently navigate the polygon, such as iterating over the edges that touch a particular vertex, or finding the faces that share a particular edge.</p><p>Below is a pseducode showing a simplified version of implementation of DCEL or Doubly-Connected Edge list Data Structure for storing a polygon:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">  class face {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  int edge;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public face(int e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    edge = e &lt; 0 ? e - 1 : e + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void printFace() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (edge &gt;= 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      System.out.println(&quot;Face with bounding edge: Forward &quot; + edge);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (edge &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      System.out.println(&quot;Face with bounding edge: Backward &quot; + edge * -1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class vertex {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  double x, y;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  int id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  int inc_Edge;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public vertex() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public vertex(double x, double y, int id) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.id = id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.x = x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.y = y;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public vertex(vertex v, int id) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.id = id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.x = v.x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.y = v.y;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void setIncEdge(int e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    inc_Edge = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public String stringForm() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return &quot;(&quot; + x + &quot;, &quot; + y + &quot;) and edge: &quot; + inc_Edge;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class edge {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  int twin;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  int next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  int prev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  int origin;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  int dest;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public edge(int o, int d) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    origin = o;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dest = d;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void printEdge(ArrayList &lt; vertex &gt; vi, int i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ++i + &quot;. Edge with origin: &quot; + vi.get(origin).stringForm() +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &quot; and dest: &quot; + vi.get(dest).stringForm() +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &quot; with next: &quot; + next +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &quot; and prev: &quot; + prev</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void setNext(ArrayList &lt; edge &gt; edgesTwin, int e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    next = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    edgesTwin.get(twin).prev = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void setPrev(ArrayList &lt; edge &gt; edgesTwin, int e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    prev = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    edgesTwin.get(twin).next = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-polygon-decomposition-algorithm">2. Polygon Decomposition Algorithm<a href="#2-polygon-decomposition-algorithm" class="hash-link" aria-label="Direct link to 2. Polygon Decomposition Algorithm" title="Direct link to 2. Polygon Decomposition Algorithm">​</a></h3><p>After storing our polygon in the aforementioned DCEL Data structure, our next step is to decompose it into smaller polygons that are convex in nature where taking into account that the smaller polygons generated are the largest possible convex polygons and not just triangulations in the initial polygon. This is achieved using the divide and conquer methodology to generate convex polygons of the partitions. </p><p>We begin with a simple polygon, P, with its vertices considered and assumed in clockwise order. The algorithm is implemented on this particular polygon P, and as it progresses, P will be modified by cutting off the convex polygons generated thus far. These generated polygons are stored in a list, L, which is initialized with a single vertex. The convex polygon with the highest possible number of vertices is generated by continuously adding supposed vertices into L.
Further, If the list L contains all the edges of the polygon, the algorithm stops indicating that the initial polygon is convex in nature while if L, has only v1 and v2 then it is considered an edge and the algorithm stops yet again.</p><p>Finally, the convex polygon is obtained by drawing the diagonal joining the last and first vertices of L. However, it is possible that the convex polygon created by the diagonal joining the last vertex to the initial vertex contains one of the interior vertices of P, and hence we need to handle this externally.
To address this issue, we initialize a &quot;check&quot; that generates the smallest rectangle R with sides parallel to the axes. If a given &quot;v&quot; is not inside the rectangle R, then it cannot be inside the polygon generated by the vertices of our earlier list L, and hence the problem is solved.</p><p>Below is a pseducode showing a simplified version of implementation of the mentioned Decomposition algorithm used in our assignment:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">      void runAlgorithm() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      System.out.println(&quot;====================================================================&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      while (n &gt; 3) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.algo();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;====================================================================&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void algo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      int i = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      vertex vi = v2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      vertex vi1 = origiPolygon.vertices.get(origiPolygon.edgesF.get(v2.inc_Edge).dest);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      vertex vim1 = v1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      System.out.println(vi1.stringForm());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      int t = origiPolygon.findIndOfVert(v1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      vertex tempV = v2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ArrayList &lt; vertex &gt; verts = new ArrayList &lt; &gt; ();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      polygon poly = new polygon();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      poly.addVertex(v1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      poly.addVertex(v2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      poly.addEdge(i - 2, i - 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      while (threeConditionsDam(v1, v2, vi, vi1, vim1) &amp;&amp; verts.size() &lt; origiPolygon.numV - 2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        i++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Adding: &quot; + vi1.stringForm());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        verts.add(vi1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (vertex te: verts) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          System.out.println(te.stringForm());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        poly.addVertex(vi1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        poly.addEdge(i - 2, i - 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vim1 = vi;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vi = vi1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vi1 = origiPolygon.vertices.get(origiPolygon.edgesF.get(vi.inc_Edge).dest);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      poly.addEdge(poly.numV - 1, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      v1 = vi;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      v2 = vi1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      System.out.println(&quot;V1: &quot; + v1.stringForm() + &quot; V2: &quot; + v2.stringForm());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      for (vertex temp: origiPolygon.vertices) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (poly.isPointIn(temp) &amp;&amp; poly.numV &gt; 2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          poly.removeLastEdge();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          poly.removeLastVertexAndEdge();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          v2 = verts.get(verts.size() - 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          verts.remove(verts.size() - 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          v1 = verts.size() &gt;= 1 ? verts.get(verts.size() - 1) : tempV;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          poly.addEdge(poly.numV - 1, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          System.out.println(&quot;Removing&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          for (vertex te: verts) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(te.stringForm());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      System.out.println(&quot;Pruning done: &quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      for (vertex te: verts) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(te.stringForm());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      System.out.println(&quot;V1: &quot; + v1.stringForm() + &quot; V2: &quot; + v2.stringForm());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (poly.numV &gt; 2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int ind = origiPolygon.findIndOfVert(verts.get(verts.size() - 1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        origiPolygon.addEdge(t, ind);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        origiPolygon.removeLastFace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        origiPolygon.addFaceWithLastEdge();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        n = n + 2 - poly.numV;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean threeConditionsDam(vertex a, vertex b, vertex vi, vertex vi1, vertex vim1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (origiPolygon.cross(vi1, vi, vim1) &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (origiPolygon.cross(a, vi1, vi) &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return !(origiPolygon.cross(b, a, vi1) &lt; 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3-merge-algorithm">3. Merge Algorithm<a href="#3-merge-algorithm" class="hash-link" aria-label="Direct link to 3. Merge Algorithm" title="Direct link to 3. Merge Algorithm">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="31-need-for-merging">3.1 Need for Merging<a href="#31-need-for-merging" class="hash-link" aria-label="Direct link to 3.1 Need for Merging" title="Direct link to 3.1 Need for Merging">​</a></h4><p>At times, the partitions generated using the above-mentioned technique, i.e., the decomposition algorithm, may have unnecessary diagonals. This could be when the two convex polygons sharing a diagonal can be combined to form a single polygon. To avoid this, we have made use of a merging algorithm.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="32-implementation-summary">3.2 Implementation Summary<a href="#32-implementation-summary" class="hash-link" aria-label="Direct link to 3.2 Implementation Summary" title="Direct link to 3.2 Implementation Summary">​</a></h4><p>In the merging process, we begin by distinguishing diagonals as essential and inessential. A diagonal, d, is considered and classified as essential for vertex v if its elimination causes a piece that is not convex at v. Subsequently, each diagonal is evaluated to determine if it can be removed and whenever necessary, the diagonal is eliminated.</p><p>Below is a pseducode showing a simplified version of implementation of the mentioned Merging algorithm used in our assignment:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    class mergingAlgo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ArrayList &lt; edge &gt; LLE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ArrayList &lt; ArrayList &lt; edge &gt;&gt; LPuj;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ArrayList &lt; Boolean &gt; LDP;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ArrayList &lt; Integer &gt; LUP;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      int m, NP;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      public void getDiagonals(polygon p, int initVert) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        LLE = new ArrayList &lt; &gt; ();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; p.vertices.size(); i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          if (p.edgesF.get(i).next == 0 &amp;&amp; p.edgesF.get(i).prev == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            LLE.add(new edge(p.edgesF.get(i).origin, p.edgesF.get(i).dest));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      public void printDiagonalCoords() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; LLE.size(); i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          System.out.println(&quot;Diagonal &quot; + i + &quot;: (&quot; + LLE.get(i).origin + &quot;, &quot; + LLE.get(i).dest + &quot;)&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      void initialize(polygon p) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 1; i &lt; LLE.size(); i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          vertex origin = p.vertices.get(LLE.get(i).origin);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          vertex dest = p.vertices.get(LLE.get(i).dest);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          vertex prevOrigin = p.vertices.get(LLE.get(LLE.get(i).prev).origin);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          vertex nextOrigin = p.vertices.get(LLE.get(LLE.get(i).next).origin);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          vertex prevDest = p.vertices.get(LLE.get(LLE.get(i).prev).dest);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          vertex nextDest = p.vertices.get(LLE.get(LLE.get(i).next).dest);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          if (isConvex(prevOrigin, origin, nextOrigin) &amp;&amp; isConvex(prevDest, dest, nextDest)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            LLE.remove(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      private static boolean orientation(vertex p, vertex q, vertex r) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return (q.y - p.y) * (r.x - q.x) &gt;= (q.x - p.x) * (r.y - q.y);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      private static boolean isConvex(vertex p, vertex q, vertex r) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return orientation(p, q, r) &amp;&amp; orientation(q, r, p) &amp;&amp; orientation(r, p, q);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      private static boolean vertexEqualityAfterAbsorption(vertex v1, vertex v2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return (v1.x == v2.x &amp;&amp; v1.y == v2.y);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="results">Results<a href="#results" class="hash-link" aria-label="Direct link to Results" title="Direct link to Results">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="visualization">Visualization<a href="#visualization" class="hash-link" aria-label="Direct link to Visualization" title="Direct link to Visualization">​</a></h3><p>To show our resultant polygon in a appealing manner, we generated a UI interface using Swing in java which shows the polygon taken as the input and the resultant polygon after the decomposition algorithm as well as the final polygon after the merging process.</p><p>Below is a snippet showing the implementation of the UI Interface.
<img loading="lazy" alt="image1" src="/assets/images/img1-b270e6eaee112609ab45a2a372c567a1.jpeg" width="700" height="481" class="img_ev3q"></p><p>Before Decomposition</p><p><img loading="lazy" alt="image2" src="/assets/images/img2-9c84b3ea528e6d4a9e5d39c46c342c20.jpeg" width="708" height="490" class="img_ev3q"></p><p>After Decomposition</p><p><img loading="lazy" alt="image3" src="/assets/images/img3-bfce55a679893fa2aae342e63e5cac58.jpeg" width="702" height="483" class="img_ev3q"></p><p>After Merging</p><p>Further, We also constructed a django based interface which uses HTML Canvas element which enables us to draw our input polygons concering the different vertices and using the rest API it finally outputs the resultant polygon as well. The input shape is sent to the back end via an API written in python. The back end then runs the java code and the output of the java code is stored in a text file. Then, the resulting vertices are displayed on the front end through another API in django.</p><p>Below is a snippet showing the same.</p><p><img loading="lazy" alt="image4" src="/assets/images/img4-0dec821d17089b918568558986f627a0.jpeg" width="1600" height="777" class="img_ev3q"></p><p>HTML Canvas</p><p><img loading="lazy" alt="image5" src="/assets/images/img5-3f093616070fca74dbb9e6b6555d7121.jpeg" width="1600" height="779" class="img_ev3q"></p><p>Input Shape</p><p><img loading="lazy" alt="image6" src="/assets/images/img6-bc9a827d511a786c91b6df50e9efebd1.jpeg" width="1600" height="780" class="img_ev3q"></p><p>Final Result</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="test-cases-and-time-complexity">Test Cases and Time Complexity<a href="#test-cases-and-time-complexity" class="hash-link" aria-label="Direct link to Test Cases and Time Complexity" title="Direct link to Test Cases and Time Complexity">​</a></h3><p>After completing the implementation of the the algorithm described above in the Methodology section, we tested our implementation of various data sets, we systematically figured out that the time complexity is propotional to O(n^3) owning to major time contribution in the Decomposition Algorithm.</p><p>The run times for a polygon is as follows:</p><table><thead><tr><th>Number of vertices</th><th>Time</th></tr></thead><tbody><tr><td>n = 8</td><td>Time taken: 12204999 nanoseconds</td></tr><tr><td>n = 16</td><td>Time taken: 11824500 nanoseconds</td></tr><tr><td>n = 32</td><td>Time taken: 11814300 nanoseconds</td></tr><tr><td>n = 64</td><td>Time taken: 12257701 nanoseconds</td></tr><tr><td>n = 150</td><td>Time taken: 12311901 nanoseconds</td></tr><tr><td>n = 200</td><td>Time taken: 13457701 nanoseconds</td></tr><tr><td>n = 500</td><td>Time taken: 10986651 nanoseconds</td></tr></tbody></table></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/intro.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#team-members" class="table-of-contents__link toc-highlight">Team Members</a></li><li><a href="#methodology" class="table-of-contents__link toc-highlight">Methodology</a><ul><li><a href="#1-dcel-data-structure" class="table-of-contents__link toc-highlight">1. DCEL Data Structure</a></li><li><a href="#2-polygon-decomposition-algorithm" class="table-of-contents__link toc-highlight">2. Polygon Decomposition Algorithm</a></li><li><a href="#3-merge-algorithm" class="table-of-contents__link toc-highlight">3. Merge Algorithm</a></li></ul></li><li><a href="#results" class="table-of-contents__link toc-highlight">Results</a><ul><li><a href="#visualization" class="table-of-contents__link toc-highlight">Visualization</a></li><li><a href="#test-cases-and-time-complexity" class="table-of-contents__link toc-highlight">Test Cases and Time Complexity</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items clean-list"></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 DAA Project. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.253a65e8.js"></script>
<script src="/assets/js/main.5ae705ac.js"></script>
</body>
</html>